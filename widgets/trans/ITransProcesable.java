package widgets.trans;

import java.util.Map;


/**
 * Інтерфейс визначає вимоги до моделей, що будуть працюватии паралельно під
 * орудою монітору widgets.trans.TransMonitor, що є складовою частиною 
 * об'єкту  widgets.trans.TransProcessManager
 * Призначення таких моделей: накопичення інформації для
 * визначення перехідного процесу для визначених параметрів моделі.
 * 
 */
	public interface ITransProcesable {

 /** Метод використовується монітором для ініціалізації моделі перед стартом.
 *  Як параметр до методу передається: тривалість моделювання finishTime, що
 * підраховується монітором як добуток від довжини інтервалу накопичення даних
 * на кількість цих інтервалів. Доцільно цей параметер передавати акторам, інакше вони 
 * можуть закінчити роботу раніше, або пізніше монітора, в залежності 
 * від попереднього налаштування часу моделювання*/
	public void initForTrans(double finishTime);
	
	/**
	 * Метод resetAccum() монітор викликає на початку кожного інтервалу накопичення даних,
	 * то ж у ньому слід реалізувати ініціалізацію накопиувачів
	 * Якщо в якості об'єкту дослідження використовується черга класу process.QueueForTransaction
	 * то для ініціалізації накопичувачів достатньо викликати метод resetAccum()
	 */
	//public void resetTransAccum();

	/**
	 * Наприкінці кожного інтервалу накопиченняіинформації, monitor (об'єкт класу widgets.trans.TransMonitor,)
	 *  за допомогою методу getTransResult(), опитує всі моделі, що працюють паралельно.
	 * Середні значення параметрів на інтервалі накопичення мають бути занесені до карти.
	 * Ключем є назва параметру, а value - середне значення параметру на інтервалі накопичення.
	 * Якщо в якості об'єкту дослідження використовується черга класу QueueForTransaction
	 * то середне накопичене значення можна отримати за допомогою методу process.getAccumAverage()
	 * 
	 */
	public Map<String, ITransMonitoring> getMonitoringObjects();
	

}
